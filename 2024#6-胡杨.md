## 2024#6-胡杨

那自然是从 Linux 的[基本操作]([Linux 命令大全 | 菜鸟教程 (runoob.com)](https://www.runoob.com/linux/linux-command-manual.html))开始咯~

截图如下~

<img src="img\basiclinux.png" alt="result"  />

### 附加题那肯定要做啊~

### Problem1

Linux 实际上也是类似于 windows 的目录结构，采用的是树状的管理。一开始我们手上捏着的就是根节点，然后根节点依次向下衍生出各种文件夹（树枝）。衍生出来的树枝一般来说有着比较固定的功能。

<details><summary>touch to expand </summary><pre>/(根目录)：这是文件系统的最顶层，所有其他目录和文件都从这里开始。
/bin：存放基本的二进制文件，如常用的命令行工具（如ls、cp、mv等）。
/boot：存放启动Linux时使用的核心文件，如vmlinuz、initrd等。
/dev：包含设备文件，例如硬盘、USB设备、键盘、鼠标等。
/etc：存放系统配置文件，如网络配置文件、用户信息、服务启动脚本等。
/home：用户的主目录，每个用户都有一个以用户名命名的目录。
/lib：存放系统库文件，这些文件为/bin和/sbin中的程序提供支持。
/mnt：临时挂载文件系统的地方。
/proc：一个虚拟文件系统，包含系统信息，如进程、内存、设备等。
/root：系统管理员（root用户）的主目录。
/sbin：存放系统管理员使用的二进制文件，如系统服务管理工具。
/tmp：存放临时文件，这些文件在系统重启时会被删除。
/usr：用户程序和文件的存放地，通常包含应用程序、库文件、头文件和文档。
    /usr/bin：用户级的应用程序。
    /usr/lib：用户级的库文件。
    /usr/local：存放本地安装的程序和文件。
    /usr/share：存放共享数据，如文档、图标等。
/var：存放经常变化的文件，如日志文件、邮件队列等。
/opt：第三方软件安装目录。
/media：挂载移动存储设备的地方。
/srv：服务启动时需要的数据文件。
/sys：与/proc类似，也是一个虚拟文件系统，但使用sysfs文件系统。
/run：存放系统运行时的临时文件。
/lost+found：非正常关机后，fsck命令会将找到的文件碎片存放在这里。
</pre></details>



~~以上来自 CharGPT~~ 

但其实最重要的几个应该是这几个

- /etc 要配置什么东西比如 nginx.config 这种东西全部在这里找
- /bin 其实不太重要，主要是我被丢失的库折磨了一番有点怨言（
- **/usr** 重中之重，一定养成平时干点什么搞点什么文件一定要在这下面搞的好习惯，最好是就在 local 下

/mnt 我其实特殊说明一下，挂载东西需要的权限还是蛮高的，挂载上硬盘还是蛮方便的（VMware本地虚拟机实操过）

但是想必这个问题并不会这么简单吧，想问的应该是 Linux 特色的文件系统吧~

段-页表-块管理

Linux 中有一个很聪明的管理方式：它选择了将内存划分成一部分一部分进行管理，每个文件存放一定是整数个划分的基本单位。如此一来查找等操作就变得极为方便了：只需要记录这个文件起始是在哪一个块，然后再加一个占用块的数量或者结束的块的编号就搞定了。但是这个样子也带来了极大的弊端：系统需要浪费很多空间去建立每一个块的索引。所以 Linux 采用了更聪明的方式：它采用了段来给块建立索引。摊开讲就是一个二级的映射。但是此时就不需要把每一个块的索引全部建立出来，再在这基础上建立索引的索引了。此时采用的策略是随用随开，不浪费索引空间，不像之前一定要开完块的索引，此时只需要把最高层的索引开完，中层的索引按照需要开就行了，节约了大量的空间。

### Problem2

额……这个不知道怎么展示，就先搁着（）

### Task1：C ++ 实现回声服务器

C++ 语法基础还有，遂直接跑去[学习 socket](https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html)。

~~但是并不想老老实实地学（被高数硬控得时间都没了）~~

于是就选择了一种非常高效率但低效率的学习方法（至于为什么后面会说）我选择了去搜 socket 相关的所有函数并进行了解，最后再去找写服务端的实例搭框架，了解整体的运行逻辑，组织起前面的基础知识。

前置：socket 标识符指也仅仅指本机的。

- socket 函数：创建一个 socket 用于通信。```int socket(int domain,int type,int protocol);``` 第一个参数是通信协议，第二个参数是协议（TCP\UDP），第三个参数通常为 0 ，只有在第二个参数为 RAW 时才需指定。返回值是 socket 文件描述符，用于指示打开的文件（实际上是 socket 的特殊标识）当它为 -1 的时候意味着创建失败。

- bind 函数：将 socket 与本地协议地址绑定起来（常常在 sever 端进行）。`` int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)`` 第一个参数是 socket 的特殊标识符，第二个参数是 ip 地址和端口号，第三个参数是第二个参数的长度。返回值为 0 意味着成功， -1 为失败。

- listen 函数：标志着（往往是服务端）准备好了，准备接收消息开始服务。``int listen(int sockfd, int backlog)`` 第一个参数是 socket 函数的标识符，第二个参数是允许排队的最多访问数量。成功返回 0，失败返回 -1 。

- connet 函数：（往往是 client 向 sever）发出申请，请求连接开始服务。``int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen)`` 函数第一个参数是 socket 标识符，第二个是要链接到的 ip & 端口，第三个是第二个的长度。成功返回 0 ，失败返回 -1 。错误原因以及可能的结果如下：

  - ①  如果客户没有收到SYN分节的响应（总共75秒，这之间可能重发了若干次SYN），则返回 ETIMEDOUT 

  - ②  如果对客户的SYN的响应是RST，则表明该服务器主机在指定的端口上没有进程在等待与之相连，函数返回错误 ECONNREFUSED

  - ③  如果客户发出的SYN在中间路由器上引发一个目的地不可达的 ICMP 错误，内核返回 EHOSTUNREACH 或 ENETUNREACH 错误（即 ICMP 错误）给进程

- accept 函数：接受 connet 的连接，返回一个新的 socket 描述符用于处理请求，原 socket 描述符仍然用于 listen 监听。``int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)`` 第一个为 socket 标识符，第二个为对面的 ip & 端口，第三个是第二个参数的长度。执行成功返回新的 socket id，失败返回 -1 。

- close 函数：关闭连接的 socket 函数标识符。``int close(int sockfd)`` 如果成功返回 0，失败返回 1 。

- shutdown 函数：终止 socket 函数通信。``int shutdown(int socketfd, int how)``  函数返回值为 0 成功， -1 为失败。函数传参第一个是 socket 标识符，第二个是代表关闭方式。具体是：

  - 当 how == 0：关闭读这一半，并且使缓冲区的数据作废。
  - 当 how == 1：关闭写这一半，并将缓冲区末尾写入一个 TCP 的终止信号，意味着留在写的缓冲区的数据将会被排队发送。
  - 当 how == 2：两个都关闭。

- 关于网络 IO 函数

  从各种简单的函数诸如 send 、recv 等函数，到复杂的高级的函数如 recvmsg、sendmsg，后两个函数几乎可以通过调参实现所有的网络 IO。

  - recvmsg 网络读 ``ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);`` 返回值是 0 和 -1 用于标识是否成功。参数：socket id，用于接收获得的信息的结构体，特殊的要求（例如：

    - `MSG_WAITALL`：等待直到接收到指定大小的数据。
    - `MSG_DONTWAIT`：设置为非阻塞模式。
    - `MSG_PEEK`：查看消息但不从队列中移除。

    其中用于接收获得的信息的结构体组成如下：

    ```c++
    struct msghdr {
        void         *msg_name;       /* 指向 发送方的地址的位置 */
        socklen_t     msg_namelen;     /* 发送的人的地址长度 */
        struct iovec *msg_iov;         /* 指定接收缓冲区 */
        int           msg_iovlen;      /* 上面那个里面的元素个数 */
        void         *msg_control;     /* 指向辅助数据的指针 */
        socklen_t     msg_controllen;  /* 接收到数据的大小 */
        int           msg_flags;       /* 接收到的消息的标志，由内核填写 */
    };

  - sendmsg 网络写 ``ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);`` 返回值同样 0 -1 代表是否成功。参数是 socket id ，发送结构体，特殊要求。

- 套接字属性控制函数

  - getsocket 函数：获取结构属性，并可以进行修改。 ``int getsockopt(int s, int level, int optname,void *optval, socklen_t *optlen)`` 参数分别是 socket 标识符，关于 ip、tcp、通用选项，访问的选项名（2、3参数搭配使用），下一个参数的长度，取得的属性值。返回成功为 0，失败为 -1。

    | level(级别) | optname(选项名) | 说明                   | 数据类型       |
    | :---------: | :-------------- | :--------------------- | :------------- |
    | SOL_SOCKET  | SO_BROADCAST    | 允许发送广播数据       | int            |
    |             | SO_DEBUG        | 允许调试               | int            |
    |             | SO_DONTROUTE    | 不查找路由             | int            |
    |             | SO_ERROR        | 获得套接字错误         | int            |
    |             | SO_KEEPALIVE    | 保持连接               | int            |
    |             | SO_LINGER       | 延迟关闭连接           | struct linger  |
    |             | SO_OOBINLINE    | 带外数据放入正常数据流 | int            |
    |             | SO_RCVBUF       | 接收缓冲区大小         | int            |
    |             | SO_SNDBUF       | 发送缓冲区大小         | int            |
    |             | SO_RCVLOWAT     | 接收缓冲区下限         | int            |
    |             | SO_SNDLOWAT     | 发送缓冲区下限         | int            |
    |             | SO_RCVTIMEO     | 接收超时               | struct timeval |
    |             | SO_SNDTIMEO     | 发送超时               | struct timeval |
    |             | SO_REUSERADDR   | 允许重用本地地址和端口 | int            |
    |             | SO_TYPE         | 获得套接字类型         | int            |
    |             | SO_BSDCOMPAT    | 与BSD系统兼容          | int            |
    | IPPROTO_IP  | IP_HDRINCL      | 在数据包中包含IP首部   | int            |
    |             | IP_OPTINOS      | IP首部选项             | int            |
    |             | IP_TOS          | 服务类型               | int            |
    |             | IP_TTL          | 生存时间               | int            |
    |  IPPRO_TCP  | TCP_MAXSEG      | TCP最大数据段的大小    | int            |
    |             | CP_NODELAY      | 不使用Nagle算法        | int            |

  - setsockopt 函数：设置套接字属性。``int setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)`` 具体同上。

#### 搭建框架！

- 服务端

  1、创建用于监听的 socket ，并且绑定上本机的地址和端口，开始监听。// 初始化

  2、创建用于连接的 socket ，不断尝试和请求进行连接，连接成功则进行操作。

- 客户端

  1、创建用于连接的 socket，并且绑定上本机的地址和端口（可省略），初始化服务器的地址端口。

  2、尝试连接服务器，进行操作。

#### 具体情况

1、死在了 connect 上

- 我服了我又栽在网络安全组配置上面了……

2、放行之后依然 telnet 不通

- 有笨比没开服务就试图使用服务……

不过好歹是解决了（

## Task2 ：访问 & 呈现

问题分析：要求实现一个查询的操作，如果是一个文件夹，那么返回它里面的东西，如果是一个文件，那么就展示出来。大体就是给一个路径，文件夹就进去 ls 一下，返回几个字符串，如果是文件，那么就要考虑怎么展示了。注意到这里用的客户端是网页，所以查询返回都应该是遵守 http 的规则。

#### 学学 http

C++ 好像方向特别的杂，用的东西特杂，没有一个主流的标准？（我搜下来好像用 libcurl、mongoose、workflow、boost 啥都有的说……所以我就随便拎了一个学（

我选的是 **cpp-httplib**。

（一点意外情况：我发现~~题目描述太模糊了~~我审题审错了（）我以为要去做一个交互页面，后面多方查询才猜题面是想用 ip + 端口 / 虚拟目录的方式……

先从 http 的语法进入吧



### http 请求

请求的格式是：**请求行、请求头部、空行、请求数据。** 分别用于表明请求方式和协议、说明服务器需要的附加信息、（空）、说明需要的具体数据（可以为空）

#### 请求行

是一个关键字开头（如 GET 等）后面用空格隔开 URL 和协议版本

```http
POST / HTTP1.1
```

#### 请求头部

由数行以“头部字段名 + : + 值 + 回车符 + 换行符 ” 的形式构成

> - **回车** \r 本义是光标重新回到本行开头，r的英文return，控制字符可以写成CR，即Carriage Return
> - **换行** \n 本义是光标往下一行（不一定到下一行行首），n的英文newline，控制字符可以写成LF，即Line Feed

```
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive

```

**最后的空行不能省！！！**

#### 请求数据

```
name=Professional%20Ajax&publisher=Wiley
```



### http 响应

响应的格式是：**状态行、消息报头、空行、响应正文**， 分别

#### 状态行

由空格分隔开 http 版本号、状态码、状态消息

```http
HTTP/1.1 200 OK
```

<details><summary>状态码与状态消息</summary><pre>
1xx：指示信息--表示请求已接收，继续处理
2xx：成功--表示请求已被成功接收、理解、接受
3xx：重定向--要完成请求必须进行更进一步的操作
4xx：客户端错误--请求有语法错误或请求无法实现
5xx：服务器端错误--服务器未能实现合法的请求
常见状态码如下:
200 OK                        //客户端请求成功
400 Bad Request               //客户端请求有语法错误，不能被服务器所理解
401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
403 Forbidden                 //服务器收到请求，但是拒绝提供服务
404 Not Found                 //请求资源不存在，eg：输入了错误的URL
500 Internal Server Error     //服务器发生不可预期的错误
503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
</pre></details>

[更多状态码和状态消息可查看此处]([HTTP 状态码 | 菜鸟教程 (runoob.com)](https://www.runoob.com/http/http-status-codes.html))

#### 消息报头

说明附加信息

```http
Date: Fri, 22 May 2009 06:07:21 GMT
Content-Type: text/html; charset=UTF-8
```

#### 空行

不可省略！

#### 响应正文 	

返回的消息，遵循 HTML 语法

```html
<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body>
</html>
```



#### 连接过程

1、客户端发送连接请求，连接后并发送 http 的请求。

2、服务端接收请求。并根据发送的请求做出对应的回应。

3、视 TCP 连接方式，选择断开或者保持连接。

4、客户端对发送回的 HTML 进行解析并渲染。

> 特别补充：当你访问某个网站的某个端口的时候，其实就是上面的过程。



那么在这里，其实可以大致摸明白我们要干什么了：

**根据发送的虚拟目录定位映射到实际的磁盘，并以 http 的方式返回数据。**

### 学习库！

参考 github 上面的 serve.cpp 以及网上的一些例子（是真的少真的羡慕 jvav 的 spring 遍地教程）（不是这也太多了吧怎么学的完啊我先根据功能找我需要的吧qwq）

- 注册自己的函数，用于处理 GET 请求：

  ```c++
  using namespace httplib;
  Sever svr;
  svr.Get("/(.*)", funtionname);
  ```

- 监听并启动服务

  ```c++
  svr.listen("ip", 8080);//ip port
  ```

- 获取网页端口后跟的路径：

  ```c++
  Request req;
  //(in Get)
  string path = req.path;
  ```

- 设置消息报头后跟的文件类型

  ```c++
  Response res;
  res.set_header("Content-Type", "text/html");
  ```

  第二个参数参考在这里:

  ![here](img\type.png)

- 设置响应的内容

  ```
  Response res;
  res.set_content(a_stirng, "text/plain");
  //后面的参数同上
  ```

- 最重要的我觉得应该是这两个

  不得不说，命名是真的好理解，一眼就懂，只是要用的时候要能想得起来（）

  ```c++
  struct Response {
    std::string version;//版本号
    int status = -1;//状态码默认状态置为-1
    std::string reason;//状态信息
    Headers headers;//用于充当报头
    std::string body;//响应正文
    std::string location; // Redirect location
  
    bool has_header(const std::string &key) const;
    std::string get_header_value(const std::string &key, const char *def = "",
                                 size_t id = 0) const;//获取头（仅仅
    uint64_t get_header_value_u64(const std::string &key, uint64_t def = 0,
                                  size_t id = 0) const;//unsigned long long get
    size_t get_header_value_count(const std::string &key) const;
    void set_header(const std::string &key, const std::string &val);//设置报头
  
    void set_redirect(const std::string &url, int status = StatusCode::Found_302);
    void set_content(const char *s, size_t n, const std::string &content_type);
    void set_content(const std::string &s, const std::string &content_type););//文件类型
    void set_content(std::string &&s, const std::string &content_type);
  
    void set_content_provider(
        size_t length, const std::string &content_type, ContentProvider provider,
        ContentProviderResourceReleaser resource_releaser = nullptr);
  
    void set_content_provider(
        const std::string &content_type, ContentProviderWithoutLength provider,
        ContentProviderResourceReleaser resource_releaser = nullptr);
  
    void set_chunked_content_provider(
        const std::string &content_type, ContentProviderWithoutLength provider,
        ContentProviderResourceReleaser resource_releaser = nullptr);
  
    void set_file_content(const std::string &path,
                          const std::string &content_type);
    void set_file_content(const std::string &path);
  
    Response() = default;
    Response(const Response &) = default;
    Response &operator=(const Response &) = default;
    Response(Response &&) = default;
    Response &operator=(Response &&) = default;
    ~Response() {
      if (content_provider_resource_releaser_) {
        content_provider_resource_releaser_(content_provider_success_);
      }
    }
    // private members...
      //所以我就不管了
    size_t content_length_ = 0;
    ContentProvider content_provider_;
    ContentProviderResourceReleaser content_provider_resource_releaser_;
    bool is_chunked_content_provider_ = false;
    bool content_provider_success_ = false;
    std::string file_content_path_;
    std::string file_content_content_type_;
  };
  ```

  还有这个

  ```c++
  struct Request {
    std::string method;
    std::string path;
    Headers headers;
    std::string body;
  //参考前面的资料，分别是请求行、请求头部、请求数据
    std::string remote_addr;
    int remote_port = -1;
    std::string local_addr;
    int local_port = -1;
  
    // for server
    std::string version;
    std::string target;
    Params params;
    MultipartFormDataMap files;
    Ranges ranges;
    Match matches;
    std::unordered_map<std::string, std::string> path_params;
  
    // for client
    ResponseHandler response_handler;
    ContentReceiverWithProgress content_receiver;
    Progress progress;
  #ifdef CPPHTTPLIB_OPENSSL_SUPPORT
    const SSL *ssl = nullptr;
  #endif
  
    bool has_header(const std::string &key) const;
    std::string get_header_value(const std::string &key, const char *def = "",
                                 size_t id = 0) const;
    uint64_t get_header_value_u64(const std::string &key, uint64_t def = 0,
                                  size_t id = 0) const;
    size_t get_header_value_count(const std::string &key) const;
    void set_header(const std::string &key, const std::string &val);
  
    bool has_param(const std::string &key) const;
    std::string get_param_value(const std::string &key, size_t id = 0) const;
    size_t get_param_value_count(const std::string &key) const;
  
    bool is_multipart_form_data() const;
  
    bool has_file(const std::string &key) const;
    MultipartFormData get_file_value(const std::string &key) const;
    std::vector<MultipartFormData> get_file_values(const std::string &key) const;
  
    // private members...
    size_t redirect_count_ = CPPHTTPLIB_REDIRECT_MAX_COUNT;
    size_t content_length_ = 0;
    ContentProvider content_provider_;
    bool is_chunked_content_provider_ = false;
    size_t authorization_count_ = 0;
  };
  ```

  

*不是哥们这个头文件里面的东西多的太恐怖了吧这么短时间学不了一点 [/大哭]

~~都怪我一拖再拖……~~

那么，加上一点逻辑与实现，就有 serve 端了。



实现效果：<img src="img\1.png" alt="1" style="zoom: 50%;" /><img src="img\2.png" alt="2" style="zoom: 50%;" /><img src="img\3.png" alt="3" style="zoom: 50%;" />

 [github 库的源文件](https://github.com/Myhanshuang/jotang/tree/master)

### 番外：吐槽某个睡不够的家伙犯迷糊

其实是个很弱智 & 很离谱的事，我在构建文件路径的时候又又又又忘记应该用相对路径了，导致文件打开失败，但是最终的 error 报在的是 fprintf 上面，我就特别头大，反复去查输出的东西是不是指针又乱飞了，搞了半天还得借助调试一个一个检查 value 才搞出来……

